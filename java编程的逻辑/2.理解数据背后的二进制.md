##                                          理解数据背后的二进制

## 1、整数的二进制的表示和运算

a  负数二进制的表示法？

这种表示法称为补码表示法，而符合我们直觉的表示称为原码表示法，补码表示就是在原码表示的基础上取反然后加1。取反就是将0变为1,1变为0。负数的二进制表示就是对应的正数的补码表示，比如：

1）-1:1的原码表示是00000001，取反是11111110，然后再加1，就是11111111。

2）-2:2的原码表示是00000010，取反是11111101，然后再加1，就是11111110。

3）-127:127的原码表示是01111111，取反是10000000，然后再加1，就是10000001。

给定一个负数的二进制表示，要想知道它的十进制值，可以采用相同的补码运算。比如：10010010，首先取反，变为01101101，然后加1，结果为01101110，它的十进制值为110，所以原值就是-110。直觉上，应该是先减1，然后再取反，但计算机只能做加法，而补码的一个良好特性就是，对负数的补码表示做补码运算就可以得到其对应正数的原码，正如十进制运算中负负得正一样。



对于byte类型，正数最大表示是01111111，即127，负数最小表示（绝对值最大）是10000000，即-128，表示范围就是-128～127。其他类型的整数也类似，负数能多表示一个数。

负整数为什么要采用这种奇怪的表示形式呢？原因是，只有这种形式，计算机才能实现正确的加减法。计算机其实只能做加法，1-1其实是1+(-1)。

b 为什么正数的运算结果可能出现负数了?

当计算结果超出表示范围的时候，最高位往往是1，然后就会被看作负数。比如，127+1：

~~~vi
               127   ->01111111                       1     -> 00000001
               1     ->00000001                      -1     -> 11111111
               + -----------------------             + ---------------------
              -128   ->10000000                       0     -> 00000000
~~~

c 十六进制的0x 和八进制的 0开头这是规定  

java 7 支持二进制常量 例如：int a=ob11001

d 位运算有移位运算和逻辑运算。移位有以下几种?

1）左移：操作符为<<，向左移动，右边的低位补0，高位的就舍弃掉了，将二进制看作整数，左移1位就相当于乘以2。

2）无符号右移：操作符为>>>，向右移动，右边的舍弃掉，左边补0。

3）有符号右移：操作符为>>，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，**原来是1就补1，原来是0就补0**，将二进制看作整数，右移1位相当于除以2。

❑ 按位与&：两位都为1才为1。          （&）   都为1                                    位与

❑ 按位或|：只要有一位为1，就为1。（|）    只要有1                                  位或

❑ 按位取反~:1变为0,0变为1。           (~)       1变0 0变1                               位取反

❑ 按位异或^：相异为真，相同为假。(^)        1和0组合  不同为1  相同为0  位异或

## 2、小数的二进制表示

a  这个结果看上去，应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1。看上去这么简单的运算，计算机怎么会出错了呢？

~~~java
      float  f=0.1f*0.1f ;  输出结果
~~~

可以精确表示为2的某次方之和的数可以精确表示，其他数则不能精确表示。

b 计算不精确，怎么办呢？

较高的精度，一种方法是将小数转化为整数进行运算，运算结束后再转化为小数；

另一种方法是使用十进制的数据类型，这个并没有统一的规范。在Java中是BigDecimal，运算更准确，

c 浮点数的表示法？

我们还是用十进制类比，十进制有科学记数法，比如123.45这个数，直接这么写，就是固定表示法，如果用科学记数法，在小数点前只保留一位数字，可以写为1.2345E2即1.2345× (10^2)，即在科学记数法中，小数点向左浮动了两位。二进制中为表示小数，也采用类似的科学表示法，形如m× (2^e)。m称为尾数，e称为指数。指数可以为正，也可以为负，负的指数表示那些接近0的比较小的数。在二进制中，单独表示尾数部分和指数部分，另外还有一个符号位表示正负

几乎所有的硬件和编程语言表示小数的二进制格式都是一样的。这种格式是一个标准，叫做IEEE 754标准，它定义了两种格式：一种是32位的，对应于Java的float；另一种是64位的，对应于Java的double。32位格式中，1位表示符号，23位表示尾数，8位表示指数。64位格式中，1位表示符号，52位表示尾数，11位表示指数。在两种格式中，除了表示正常的数，标准还规定了一些特殊的二进制形式表示一些特殊的值，比如负无穷、正无穷、0、NaN（非数值，比如0乘以无穷大）。

## 3、字符的编码和乱码

a  常见非Unicode编码

​    1 ASCII  -- 全称是American Standard Code for InformationInterchange，即美国信息互换标准代码。

128个字符用7位刚好可以表示，计算机存储的最小单位是byte，即8位，ASCII码中最高位设置为0，用剩下的7位表示字符。这7位可以看作数字0～127, ASCII码规定了从0～127的每个数字代表什么含义。 

数字32～126表示的字符都是可打印字符，0～31和127表示一些不可以打印的字符，这些字符一般用于控制目的，这些字符中大部分都是不常用的，表2-4列出了其中相对常用的字符。

  2 ISO 8859-1  ISO 8859-1又称Latin-1，它也是使用一个字节表示一个字符，其中0～127与ASCII一样，128～255规定了不同的含义。在128～255中，128～159表示一些控制字符，这些字符也不常用，就不介绍了。160～255表示一些西欧字符

3 Windows-1252 而标准比较早。实际中使用更为广泛的是Windows-1252编码，这个编码与ISO 8859-1基本是一样的，区别只在于数字128～159

4  GB2312 GB2312标准主要针对的是简体中文常见字符，包括约7000个汉字和一些罕用词和繁体字。

GB2312固定使用两个字节表示汉字，在这两个字节中，最高位都是1，如果是0，就认为是ASCII字符。在这两个字节中，其中高位字节范围是0xA1～0xF7，低位字节范围是0xA1～0xFE。

5  GBK  	需要注意的是，低位字节是从0x40（也就是64）开始的，也就是说，低位字节的最高位可能为0。那怎么知道它是汉字的一部分，还是一个ASCII字符呢？其实很简单，因为汉字是用固定两个字节表示的，在解析二进制流的时候，如果第一个字节的最高位为1，那么就将下一个字节读进来一起解析为一个汉字，而不用考虑它的最高位，解析完后，跳到第三个字节继续解析。

6 .GB18030  用两个字节已经表示不了GB18030中的所有字符，GB18030使用变长编码，有的字符是两个字节，有的是四个字节。在两字节编码中，字节表示范围与GBK一样。在四字节编码中，第一个字节的值为0x81～0xFE，第二个字节的值为0x30～0x39，第三个字节的值为0x81～0xFE，第四个字节的值为0x30～0x39。解析二进制时，如何知道是两个字节还是4个字节表示一个字符呢？看第二个字节的范围，如果是0x30～0x39就是4个字节表示，因为两个字节编码中第二个字节都比这个大。

总结 ：

ASCII码是基础，使用一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容ASCII的，最高位使用1来进行区分。西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。我国内地的三个主要编码GB2312、GBK、GB18030有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。我国香港特别行政区和我国台湾地区的主要编码是Big5。如果文本里的字符都是ASCII码字符，那么采用以上所说的任一编码方式都是一样的。但如果有高位为1的字符，除了GB2312、GBK、GB18030外，其他编码都是不兼容的。比如，Windows-1252和中文的各种编码是不兼容的，即使Big5和GB18030都能表示繁体字，其表示方式也是不一样的，而这就会出现所谓的乱码，具体我们稍后介绍。

b  常见Unicode编码

Unicode 做了一件事，就是给世界上所有字符都分配了一个唯一的数字编号，这个编号范围从0x000000～0x10FFFF，包括110多万。但大部分常用字符都在0x0000～0xFFFF之间，即65 536个数字之内。每个字符都有一个Unicode编号，这个编号一般写成十六进制，在前面加U+。大部分中文的编号范围为U+4E00～U+9FFF，例如，“马”的Unicode是U+9A6C。

简单理解，Unicode主要做了这么一件事，就是给所有字符分配了唯一数字编号。它并没有规定这个编号怎么对应到二进制表示，这是与上面介绍的其他编码不同的，其他编码都既规定了能表示哪些字符，又规定了每个字符对应的二进制是什么，而Unicode本身只规定了每个字符的数字编号是多少。

1  UTF-32 这个最简单，就是字符编号的整数二进制形式，4个字节。但有个细节，就是字节的排列顺序，如果第一个字节是整数二进制中的最高位，最后一个字节是整数二进制中的最低位，那这种字节序就叫“大端”（Big Endian, BE），否则，就叫“小端”（Little Endian, LE）。对应的编码方式分别是UTF-32BE和UTF-32LE。可以看出，每个字符都用4个字节表示，非常浪费空间，实际采用的也比较少。

2 UTF-16常用于系统内部编码，UTF-16比UTF-32节省了很多空间，但是任何一个字符都至少需要两个字节表示，对于美国和西欧国家而言，还是很浪费的。

3 UTF-8 

表2-6中的x表示可以用的二进制位，而每个字节开头的1或0是固定的。小于128的，编码与ASCII码一样，最高位为0。其他编号的第一个字节有特殊含义，最高位有几个连续的1就表示用几个字节表示，而其他字节都以10开头。对于一个Unicode编号，具体怎么编码呢？首先将其看作整数，转化为二进制形式（去掉高位的0），然后将二进制位从右向左依次填入对应的二进制格式x中，填完后，如果对应的二进制格式还有没填的x，则设为0。我们来看个例子，“马”的Unicode编号是0x9A6C，整数编号是39532，其对应的UTF-8二进制格式是：

~~~text
     1110XXXx  10xxxxxx  10xxxxxx  UTF-8二进制格式是
         1001    101001    101100  二进制格式
  ------------------------------------ 
     11101001  10101001  10101100  UTF-8编码
~~~

整数编号39 532的二进制格式是：

~~~text
         1001 101001 101100
~~~

十六进制表示为0xE9A9AC。和UTF-32/UTF-16不同，UTF-8是兼容ASCII的，对大部分中文而言，一个中文字符需要用三个字节表示

举例来说，“马”从GB18030转到UTF-8，先查GB18030->Unicode编号表，得到其编号是9A 6C，然后查Uncode编号->UTF-8表，得到其UTF-8编码：E9 A9 AC。编码转换改变了字符的二进制内容，但并没有改变字符看上去的样子。

c  乱码的原因？

．解析错误  



．错误的解析和编码转换

如果怎么改变查看方式都不对，那很有可能就不仅仅是解析二进制的方式不对，而是文本在错误解析的基础上还进行了编码转换

1）两个字“老马”，本来的编码格式是GB18030，编码（十六进制）是C0 CF C2 ED。

2）这个二进制形式被错误当成了Windows-1252编码，解读成了字符“ÀÏÂí”。

3）随后这个字符进行了编码转换，转换成了UTF-8编码，形式还是“ÀÏÂí”，但二进制变成了C3 80 C3 8F C3 82 C3 AD，每个字符两个字节。

4）这个时候再按照GB18030解析，字符就变成了乱码形式“脌脧脗铆”，而且这时无论怎么切换查看编码的方式，这个二进制看起来都是乱码。

这种情况其实很常见，计算机程序为了便于统一处理，经常会将所有编码转换为一种方式，比如UTF-8，在转换的时候，需要知道原来的编码是什么，但可能会搞错，而一旦搞错并进行了转换，就会出现这种乱码。这种情况下，无论怎么切换查看编码方式都是不行的，如表2-8所示。

d  错误的解析和编码转换 乱码解决方式？

下面我们来看如何使用Java恢复乱码。关于使用Java我们还有很多知识没有介绍，为了完整性起见，本节一并列出相关代码，初学者不明白的可以暂时略过。Java中处理字符串的类有String, String中有我们需要的两个重要方法。1）public byte[] getBytes(String charsetName)，这个方法可以获取一个字符串的给定编码格式的二进制形式。2）public String(byte bytes[], String charsetName)，这个构造方法以给定的二进制数组bytes按照编码格式charsetName解读为一个字符串。将A看作GB18030，将B看作Windows-1252，



## 剖析Integer与二进制算法

~~~java
                 0001  0010  0011  0100 0101 0110  0111 1000    --0x12345678
                 0000                              0001 0010    --0x00000012
                     
~~~

~~~mermaid
graph LR
A[方形] -->B(圆角)

    B --> C{条件a}

    C -->|a=1| D[结果1]

    C -->|a=2| E[结果2]

    F[横向流程图]

~~~

~~~sequence
Title: 标题：复杂使用

对象A->对象B: 对象B你好吗?（请求）

Note right of 对象B: 对象B的描述

Note left of 对象A: 对象A的描述(提示)

对象B-->对象A: 我很好(响应)

对象B->小三: 你好吗

小三-->>对象A: 对象B找我了

对象A->对象B: 你真的好吗？

Note over 小三,对象B: 我们是朋友

participant C

Note right of C: 没人陪我玩
~~~

