#                                                         编程基础

## 1、数据类型和变量



## 2、赋值

### 2.1 数组

   ~~~visual basic
int[] array=new int[3]{1,2,3} 不允许这种写法   ##可以这么理解，因为初始值已经决定了长度，再给个长度，如果还不一致，计算机将无所适从。 
   ~~~

数组类型和基本类型是有明显不同的，一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块：一块用于存储数组内容本身，另一块用于存储内容的位置。用一个例子来说明，有一个int变量a，以及一个int数组变量arr，其代码、变量对应的内存地址和内存内容如下图所示：



![IMG20200528-200332619](D:\mygithublearning\learning\java编程的逻辑\IMG20200528-200332619.jpeg)

基本类型a的内存地址是1000，这个位置存储的就是它的值100。数组类型arr的内存地址是2000，这个位置存储的值是一个位置3000,3000开始的位置存储的才是实际的数据“1, 2, 3”。为什么数组要用两块空间？不能只用一块空间吗？我们来看下面这段代码：

~~~java
   int[] arrayA=new int[3]{1,2,3} 
   int[] arrayB=new int[4]{4,5,6,7} 
   arrayA=arrayB
~~~

这段代码中，arrA初始的长度是3, arrB的长度是4，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。用两块空间存储就简单得多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4,5,6,7}的地址，此后访问arrA就和arrB是一样的了，而arrA {1,2,3}的内存空间由于不再被引用会进行垃圾回收，   

由上也可以看出，给数组变量赋值和给数组中元素赋值是两回事，给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。

上面我们说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但可以改变数组变量的值，让它指向一个长度不同的空间，就像上例中arrA后来指向了arrB一样。

### 3、基本运算

a

~~~visual basic
float  f=0.1f*0.1f ;
System.out.println(f);
这个结果看上去应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1? 换用double看看?
double  d=0.1*0.1 ;
System.ount.println(d); 屏幕输出0.010000000000000002，一连串的0之后多了个2，结果也不精确。?
~~~

b 如果只是对自己操作，这两种形式也没什么差别，区别在于还有其他操作的时候。放在变量后（a++）是先用原来的值进行其他操作，然后再对自己做修改，而放在变量前（++a）是先对自己做修改，再用修改后的值进行其他操作。（都是以自己为基准）

c 逻辑运算

❑ 与（&）：两个都为true才是true，只要有一个是false就是false；

❑ 或（|）：只要有一个为true就是true，都是false才是false；

❑ 非（!）：针对一个变量，true会变成false, false会变成true；

❑ 异或（^）：两个相同为false，两个不相同为true；

❑ 短路与（&&）：和&类似，不同之处稍后解释；（推荐）前面一个为true  后面逻辑忽略

❑ 短路或（||）：与|类似，不同之处稍后解释。 （推荐）前面一个为false 后面逻辑忽略

d if/else if/else陷阱：需要注意的是，在if/else if/else中，判断的顺序是很重要的，后面的判断只有在前面的条件为false的时候才会执行。

e  if/else if/else的实现原理？

switch的转换和具体系统实现有关。如果分支比较少，可能会转换为跳转指令。如果分支比较多，使用条件跳转会进行很多次的比较运算，效率比较低，可能会使用一种更为高效的方式，叫跳转表。跳转表是一个映射表，存储了可能的值以及要跳转到的地址，如表1-5所示。

跳转表为什么会更为高效呢？因为其中的值必须为整数，且按大小顺序排序。按大小排序的整数可以使用高效的二分查找，即先与中间的值比，如果小于中间的值，则在开始和中间值之间找，否则在中间值和末尾值之间找，每找一次缩小一半查找范围。如果值是连续的，则跳转表还会进行特殊优化，优化为一个数组，连找都不用找了，值就是数组的下标索引，直接根据值就可以找到跳转的地址。即使值不是连续的，但数字比较密集，差的不多，编译器也可能会优化为一个数组型的跳转表，没有的值指向default分支。程序源代码中的case值排列不要求是排序的，编译器会自动排序。之前说switch值的类型可以是byte、short、int、char、枚举和String。其中byte/short/int本来就是整数，char本质上也是整数（2.4节介绍），而枚举类型也有对应的整数（5.4节介绍）, String用于switch时也会转换为整数。不可以使用long，为什么呢？跳转表值的存储空间一般为32位，容纳不下long。简单说明下String, String是通过hashCode方法（7.2节介绍）转换为整数的，但不同String的hashCode可能相同，跳转后会再次根据String的内容进行比较判断。

简单总结下，条件执行的语法是比较自然和容易理解的，需要注意的是其中的一些语法细节和陷阱。它执行的本质依赖于条件跳转、无条件跳转和跳转表。条件执行中的跳转只会跳转到跳转语句以后的指令，能不能跳转到之前的指令呢？可以，那样就会形成循环。

f  可变长度参数的函数

~~~java
public static int max(int min,int ... a){
    
}
~~~

这个max函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。可变长度参数的语法是在数据类型后面加三个点“... ”，在函数内，可变长度参数可以看作是数组。可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度的参数。可变长度参数实际上会转换为数组参数，也就是说，函数声明max(intmin, int... a)实际上会转换为max(int min, int[] a)，在main函数调用max(0,2,4,5)的时候，实际上会转换为调用max(0, new int[]{2,4,5})，使用可变长度参数主要是简化了代码书写。

g 函数调用的基本原理

我们之前谈过程序执行的基本原理：CPU有一个指令指示器，指向下一条要执行的指令，要么顺序执行，要么进行跳转（条件跳转或无条件跳转）。基本上，这依然是成立的，程序从main函数开始顺序执行，函数调用可以看作一个无条件跳转，跳转到对应函数的指令处开始执行，碰到return语句或者函数结尾的时候，再执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。

1）参数如何传递？

2）函数如何知道返回到什么地方？在if/else、for中，跳转的地址都是确定的，但函数自己并不知道会被谁调用，而且可能会被很多地方调用，它并不能提前知道执行结束后返回哪里。

3）函数结果如何传给调用方？

main函数的相关数据放在栈的最下面，每调用一次函数，都会将相关函数的数据入栈，调用结束会出栈。

数组和对象的内存分配

![IMG20200529-094401699](D:\mygithublearning\learning\java编程的逻辑\IMG20200529-094401699.jpeg)



![IMG20200529-094520623](D:\mygithublearning\learning\java编程的逻辑\IMG20200529-094520623.jpeg)

对于数组arr，在栈中存放的是实际内容的地址0x1000，存放地址的栈空间会随着入栈分配，出栈释放，但存放实际内容的堆空间不受影响。但说堆空间完全不受影响是不正确的，在这个例子中，当main函数执行结束，栈空间没有变量指向它的时候，Java系统会自动进行垃圾回收，从而释放这块空间。

递归调用的原理

本节介绍了函数调用的基本原理，函数调用主要是通过栈来存储相关的数据，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单认为是通过一个专门的返回值存储器存储的。从函数调用的过程可以看出，调用是有成本的，每一次调用都需要分配额外的栈空间用于存储参数、局部变量以及返回地址，需要进行额外的入栈和出栈操作。在递归调用的情况下，如果递归的次数比较多，这个成本是比较可观的，所以，如果程序可以比较容易地改为其他方式，应该考虑其他方式。另外，栈的空间不是无限的，一般正常调用都是没有问题的，但如果栈空间过深，系统就会抛出错误java.lang.StackOverflowError，即栈溢出。至此，关于编程的基础知识，包括数据类型和变量、赋值、基本运算、流程控制中的条件执行和循环，以及函数的概念和基本原理，就介绍完了。我们谈到，在Java中，函数必须放在类中，目前我们简单认为类只是函数的容器，但类在Java中远不止有这个功能，它还承载了很多概念和思维方式，在探讨类的概念之前，在下一章，我们先来进一步理解下各种基本数据类型和文本背后的二进制表示。

