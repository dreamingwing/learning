# concurrent-basic

## 1、简述线程、进程、程序的基本概念？

🦅 **程序**

程序，是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。

🦅 **进程**

进程，是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。

🦅 **线程**

线程，与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

## 2、什么是多线程上下文切换？

## 3、线程的生命周期？

- 新建(new)   --当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：`Thread t1 = new Thread()` 。
- 可运行(runnable) --线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。例如：`t1.start()` 。
- 运行(running)--线程获得 CPU 资源正在执行任务（`#run()` 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。
- 死亡(dead)--当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。
   自然终止：正常运行完 `#run()`方法，终止。
   异常终止：调用 `#stop()` 方法，让一个线程终止运行。
- 堵塞(blocked)--由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵塞状态。直到线程进入可运行(runnable)状态，才有机会再次获得 CPU 资源，转到运行(running)状态。阻塞的情况有三种：

   - 正在睡眠：调用 `#sleep(long t)` 方法，可使线程进入睡眠方式。

   - 正在等待：调用 `#wait()` 方法。

   - 被另一个线程所阻塞：调用 `#suspend()` 方法。

🦅 **如何结束一个一直运行的线程？**

方式一，使用退出标志，这个 flag 变量要多线程可见。

方式二，使用 interrupt 方法，结合 isInterrupted 方法一起使用。

这里我们给出的建议是，不要使用 `Thread#stop()· 方法，而是使用 Thread 提供的`#interrupt()` 方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。

🦅 **一个线程如果出现了运行时异常会怎么样?**

如果这个异常没有被捕获的话，这个线程就停止执行了。

另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。

## 4、创建线程的方式及实现？

- 方式一，继承 Thread 类创建线程类。

- 方式二，通过 Runnable 接口创建线程类。

- 方式三，通过 Callable 和 Future 创建线程

- 创建线程的三种方式的对比：

  - 使用方式一

    - 优点：编写简单，如果需要访问当前线程，则无需使用 `Thread#currentThread()` 方法，直接使用 `this`即可获得当前线程。
    - 缺点：线程类已经继承了 Thread 类，所以不能再继承其他父类。

  - 使用方式二、或方式三

    - 优点：

      - 线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。

      - 在这种方式下，多个线程可以共享同一个 `target` 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

        ```
        Runnable runner = new Runnable(){ ... };
        // 通过new Thread(target, name) 方法创建新线程
        new Thread(runna,"新线程1").start();
        new Thread(runna,"新线程2").start();
        ```

        - 当然，实际比较少这么用。

      - 【最重要】**可以使用线程池**。

    - 缺点：编程稍微复杂，如果要访问当前线程，则必须使用`Thread#currentThread()` 方法。

🦅 **start 和 run 方法有什么区别？**

- 当你调用 start 方法时，你将创建新的线程，并且执行在 run 方法里的代码。

- 但是如果你直接调用 run 方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。

## 5、如何使用 wait + notify 实现通知机制？

- 首先，wait、notify 方法是针对对象的，调用任意对象的 wait 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify 方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行。

- 其次，wait、notify 方法必须在 `synchronized` 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。

🦅 **Thread类的 sleep 方法和对象的 wait 方法都可以让线程暂停执行，它们有什么区别？**

- sleep 方法，是线程类 Thread 的静态方法。调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）
- wait 方法，是 Object 类的方法。调用对象的 `#wait()` 方法，会导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 `#notify()` 方法（或`#notifyAll()`方法）时，才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

  🦅 **请说出与线程同步以及线程调度相关的方法？**

- wait 方法，使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁。
- sleep 方法，使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常。
- notify 方法，唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关。
- notityAll 方法，唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。

🦅 **notify 和 notifyAll 有什么区别？**

当一个线程进入 wait 之后，就必须等其他线程 notify/notifyAll 。

- 使用 notifyAll,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。
- 如果没把握，建议 notifyAll ，防止 notify 因为信号丢失而造成程序错误。

🦅 **为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？**

一个很明显的原因是 Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。

由于 wait，notify 和 notifyAll 方法都是锁级别的操作，所以把它们定义在 Object 类中，因为锁属于对象。

🦅 **为什么 wait 和 notify 方法要在同步块中调用？**

- Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。
- 还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。

🦅 **为什么你应该在循环中检查等待条件？**

处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。

所以，我们不能写 `if (condition)` 而应该是 `while (condition)` ，特别是 CAS 竞争的时候。示例代码如下：

```
// The standard idiom for using the wait method
synchronized (obj) {
    while (condition does not hold) {
        obj.wait(); // (Releases lock, and reacquires on wakeup)
    }
    ... // Perform action appropriate to condition
}
```

- 另外，也可以看看 [《wait 必须放在 while 循环里面的原因探析》](https://blog.csdn.net/qq_35181209/article/details/77362297)

## 6、sleep、join、yield 方法有什么区别？

1）sleep 方法

在指定的毫秒数内，让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有`synchronized` 同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常。

比如有两个线程同时执行(没有 `synchronized`)，一个线程优先级为`MAX_PRIORITY` ，另一个为 `MIN_PRIORITY` 。

- 如果没有 sleep 方法，只有高优先级的线程执行完成后，低优先级的线程才能执行。但当高优先级的线程 `#sleep(5000)` 后，低优先级就有机会执行了。
- 总之，sleep 方法，可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。

2）yield 方法

yield 方法和 sleep 方法类似，也不会释放“锁标志”，区别在于：

- 它没有参数，即 yield 方法只是使当前线程重新回到可执行状态，所以执行yield 的线程有可能在进入到可执行状态后马上又被执行。
- 另外 yield 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep 方法不同。

3）join 方法

Thread 的非静态方法 join ，让一个线程 B “加入”到另外一个线程 A 的尾部。在线程 A 执行完毕之前，线程 B 不能工作。示例代码如下：

~~~java
Thread t = new MyThread();
t.start();
t.join();
~~~

🦅 **为什么 Thread 类的 sleep 和 yield 方法是静态的？**

Thread 类的 sleep 和 yield 方法，将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。

🦅 **sleep(0) 有什么用途？**

`Thread#sleep(0)` 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 `Thread#sleep(0)` 方法，把当前线程确实的被冻结了一下，让其他线程有机会优先执行。`Thread#sleep(0)` 方法，是你的线程暂时放弃 CPU ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个**让位动作**。

而sleep(0)之所以马上回去参与cpu竞争，是因为调用sleep(0)后，因为0的原因，线程直接回到就绪队列，而非进入等待队列，只要进入就绪队列，那么它就参与cpu竞争。

## 7、interrupted 和 isInterrupted 方法的区别？

1）interrupt 方法

`Thread#interrupt()` 方法，用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。

注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出 InterruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。

2）interrupted

`Thread#interrupted()` **静态**方法，查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 `#interrupted()` 方法则返回 `true` ，第二次和后面的就返回 `false` 了。

~~~java
// Thread.java

public static boolean interrupted() {
    return currentThread().isInterrupted(true); // 清理
}

private native boolean isInterrupted(boolean ClearInterrupted);

~~~



3）interrupted

`Thread#isInterrupted()` 方法，查询指定线程的中断状态，不会清除原状态。代码如下：

~~~java
// Thread.java

public boolean isInterrupted() {
    return isInterrupted(false); // 不清除
}

private native boolean isInterrupted(boolean ClearInterrupted);

~~~

## 8、什么叫线程安全？

线程安全，是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。

🦅 **Servlet 是线程安全吗？**

Servlet 不是线程安全的，Servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。

🦅 **Struts2 是线程安全吗？**

Struts2 的 Action 是多实例多线程的，是线程安全的，每个请求过来都会 `new` 一个新的 Action 分配给这个请求，请求完成后销毁。

🦅 **SpringMVC 是线程安全吗？**

不是的，和 Servlet 类似的处理流程。

🦅 **单例模式的线程安全性?**

老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：

- 饿汉式单例模式的写法：线程安全
- 懒汉式单例模式的写法：非线程安全
- 双检锁单例模式的写法：线程安全

## 9、多线程同步和互斥有几种实现方法，都是什么？

1）**线程同步**

线程同步，是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。

线程间的同步方法，大体可分为两类：用户模式和内核模式。顾名思义：

- 内核模式，就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态。内核模式下的方法有：
  - 事件
  - 信号量
  - 互斥量
- 用户模式，就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：
  - 原子操作（例如一个单一的全局变量）
  - 临界区

2）**线程互斥**

线程互斥，是指对于共享的进程系统资源，在各单个线程访问时的排它性。

- 当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。
- 线程互斥可以看成是一种特殊的线程同步。

🦅 **如何在两个线程间共享数据？**

在两个线程间**共享变量**，即可实现共享。

一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。

🦅 **怎么检测一个线程是否拥有锁？**

调用 `Thread#holdsLock(Object obj)` **静态**方法，它返回 `true` 如果当且仅当当前线程拥有某个具体对象的锁。代码如下：

~~~java
// Thread.java

public static native boolean holdsLock(Object obj);

~~~

🦅 **10 个线程和 2 个线程的同步代码，哪个更容易写？**

写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。

但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识

## 10、什么是 ThreadLocal 变量？

ThreadLocal ，是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。

它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用 ThreadLocal 让 SimpleDateFormat 变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。

- 首先，通过复用减少了代价高昂的对象的创建个数。
- 其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。

🦅 **什么是 InheritableThreadLocal ？**

InheritableThreadLocal 类，是 ThreadLocal 类的子类。ThreadLocal 中每个线程拥有它自己的值，与 ThreadLocal 不同的是，**InheritableThreadLocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的值**。

🦅 **在多线程环境下，SimpleDateFormat 是线程安全的吗？**

不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，**如将 SimpleDateFormat 限制在 ThreadLocal 中**。

如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。

## 11、如何在 Java 中获取线程堆栈？

- `kill -3 [java pid]`

  不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如， `kill -3 tomcat pid` , 输出堆栈到 log 目录下。

- `Jstack [java pid]`

  这个比较简单，在当前终端显示，也可以重定向到指定文件中。

- [`JVisualVM：Thread Dump`](https://juejin.im/post/5a3b92def265da4319567218)

  不做说明，打开 JVisualVM 后，都是界面操作，过程还是很简单的。

## 12、什么是Java Timer 类？

`java.util.Timer` ，是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer 类可以用安排一次性任务或者周期任务。

`java.util.TimerTask` ，是一个实现了 Runnable 接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。

目前有开源的 Qurtz 可以用来创建定时任务。

## 13、你有哪些多线程开发良好的实践？

1、给线程命名。

2、最小化同步范围。

~~~java
锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。
~~~

3、优先使用 `volatile` ，而不是 `synchronized` 。

4、尽可能使用更高层次的并发工具而非 wait 和 notify 方法来实现线程通信。

~~~java
首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用 wait 和 notify 很难实现对复杂控制流的控制。
~~~

5、优先使用并发容器，而非同步容器。

~~~java
这是另外一个容易遵循且受益巨大的最佳实践，并发容器比同步容器的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到 Map ，我们应该首先想到用 ConcurrentHashMap 类。
~~~

6、考虑使用线程池。

## 14、并发编程和并行编程有什么区别？

并发（Concurrency）和并行（Parallellism）是：

- 解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
- 解释二：并行是在不同实体上的多个事件；并发是在同一实体上的多个事件。
- 解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如 Hadoop 分布式集群。

所以并发编程的目标是，充分的利用处理器的每一个核，以达到最高的处理性能。

## 15、同步和异步有何异同，在什么情况下分别使用他们？

如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行**同步**存取。

当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用**异步**编程，在很多情况下采用异步途径往往更有效率。

## 16、Java 中的多线程

- 通过 JDK 中的 java.lang.Thread 可以实现多线程。
- Java 中多线程运行的程序可能是并发也可能是并行，取决于操作系统对线程的调度和计算机硬件资源（ CPU 的个数和 CPU 的核数）。
- CPU 资源比较充足时，多线程被分配到不同的 CPU 资源上，即并行；CPU 资源比较紧缺时，多线程可能被分配到同个 CPU 的某个核上去执行，即并发。
- 不管多线程是并行还是并发，都是为了提高程序的性能。