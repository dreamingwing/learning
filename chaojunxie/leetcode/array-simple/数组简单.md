## [1431. 拥有最多糖果的孩子](https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/)

~~~text
给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。

对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。

~~~

~~~java
package leetcode.chaojun.xie.array.simple;

import java.util.ArrayList;
import java.util.List;

public class KidsWithCandies {
	public static void main(String[] args) {
		int[] candies = new int[] {2,3,5,1,3};
		int extraCandies = 3;
		List<Boolean> kidsWithCandies = kidsWithCandies(candies, extraCandies);
		for (Boolean boolean1 : kidsWithCandies) {
			System.out.println(boolean1);
		}
	}

	private static List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
		List<Boolean>  list=new ArrayList<>();
//		计算数组最大值
		int maxArray = maxArray(candies);
		for (int i = 0; i < candies.length; i++) {
			int j = candies[i];
			j+=extraCandies;
			if(j>=maxArray) {
				list.add(Boolean.TRUE);
			}else {
				list.add(Boolean.FALSE);
			}
		}
		return list;
	}

	private static int maxArray(int[] candies) {
		  int max=candies[0];
		  for (int i = 1; i < candies.length; i++) {
			if(max<candies[i]) {
				max=candies[i];
			}
		}
		return max;
	}
}

~~~

## [1450. 在既定时间做作业的学生人数](https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/)

~~~text
给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。

已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。

请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。

~~~

~~~java
package leetcode.chaojun.xie.array.simple;

public class BusyStudent {
    public static void main(String[] args) {
    	int[] startTime=new int[] {1,2,3};
		int[] endTime=new int[] {3,2,7};
		int queryTime=4;
		int busyStudent = busyStudent(startTime,endTime,queryTime);
		System.out.println(busyStudent);
	}

	private static int busyStudent(int[] startTime, int[] endTime, int queryTime) {
		int count=0;
		for (int i = 0; i < endTime.length; i++) {
			int j = endTime[i];
			int m = startTime[i];
			if(queryTime<=j&&queryTime>=m) {
				count++;
			}
		}
		return count;
	}
}

~~~

## [1460. 通过翻转子数组使两个数组相等](https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/)

~~~text
给你两个长度相同的整数数组 target 和 arr 。

每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。

如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。

~~~

~~~java
package leetcode.chaojun.xie.array.simple;

import java.util.HashMap;
import java.util.Map;

public class CanBeEqual {
     public static void main(String[] args) {
		int[] arr=new int[] {1,4,2,3};
		int[] target=new int[] {1,4,3,2};  //{1,4,2,3}  {1,2,4,3} {1,2,3,4}
		boolean canBeEqual = canBeEqual(target,arr);
		System.out.println(canBeEqual);
	}

	/*
	 * private static boolean canBeEqual(int[] target, int[] arr) { // 判断不能进行翻转的情况
	 * 其他都是能翻转的 if (target.length != arr.length) { return false; }
	 * Arrays.sort(target); Arrays.sort(arr);
	 * 
	 * for (int i = 0; i < arr.length; i++) { if (target[i]!=arr[i]){ return false;
	 * } } return true; }
	 */
    	    public static boolean canBeEqual(int[] target, int[] arr) {

    	        HashMap<Integer, Integer> map1 = new HashMap<>();
    	        HashMap<Integer, Integer> map2 = new HashMap<>();

    	        for (int i : arr) {
    	            if (map1.containsKey(i)) {
    	                map1.put(i, map1.get(i) + 1);
    	            } else {
    	                map1.put(i, 1);
    	            }
    	        }

    	        for (int i : target) {
    	            if (map2.containsKey(i)){
    	                map2.put(i, map2.get(i) + 1);
    	            } else {
    	                map2.put(i, 1);
    	            }
    	        }

    	        for (Map.Entry<Integer, Integer> entry : map1.entrySet()) {
    	            if (map2.containsKey(entry.getKey())) {
    	                if (map2.get(entry.getKey()) != entry.getValue()) {
    	                    return false;
    	                }
    	            } else {
    	                return false;
    	            }
    	        }
    	        return true;
    	    }
    	}

~~~

## [1464. 数组中两元素的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/)

~~~tex
给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。

请你计算并返回该式的最大值。

~~~

~~~java
package leetcode.chaojun.xie.array.simple;

public class MaxProduct {
	public static void main(String[] args) {
		int[] nums = new int[] { 3, 4, 5, 2 };
		int maxProduct = maxProduct(nums);
		System.out.println(maxProduct);
		
	}

	private static int maxProduct(int[] nums) {
//            获取最大的两个数   采用冒泡的方式获取
		   for (int i = 0; i < 2; i++) {
			   
			for (int j=0; j < nums.length-1; j++) {
				if(nums[j]>nums[j+1]) {
					int temp=nums[j];
					nums[j]=nums[j+1];
					nums[j+1]=temp;
				}
			}
		}
		return (nums[nums.length-1]-1)*(nums[nums.length-2]-1);
	}
}

~~~

## [1470. 重新排列数组](https://leetcode-cn.com/problems/shuffle-the-array/)

~~~text
给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。

请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。
~~~

~~~java
package leetcode.chaojun.xie.array.simple;

import java.util.ArrayList;
import java.util.List;

public class Shuffle {
	public static void main(String[] args) {
		int[] nums = new int[] { 2, 5, 1, 3, 4, 7 };
		int n = 3;
		int[] shuffle = shuffle(nums, n);
		for (Integer object : shuffle) {
			System.out.println(object);
		}
	}

	private static int[] shuffle(int[] nums, int n) {
//		List<Integer>  list=new ArrayList<>();
//		int[] num=new int[2*n];
//		int count=0;
//		     for (int i = 0; i < n; i++) {
//		    	 for (int j = i; j < nums.length;) {
//		    		 num[count]=nums[j];
//		    		 count++;
//		    		 j+=n;
//					}
//			}
//			return num;
		 //1、新建一个数组用来存放排好的数
		 int[] arry = new int[nums.length];
		 
		 //2、用for来排好
		 int j =0; 
		 //循环 nums/2 次 
		 for(int i = 0 ; i < nums.length/2 ; i++){
			 arry[j++] = nums[i];  //第一个位置放 第 i个元素，每次j++自增1
			 
			 arry[j++] = nums[n +i]; //从第n+i 就是从一半开始到数组的最后
		 }
		 //3、存到新数组里
		return arry;
             
	}
}

~~~

## [1475. 商品折扣后的最终价格](https://leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop/)

~~~tex
给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。
商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j > i 且 prices[j] <= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。
请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格
~~~

~~~java
package leetcode.chaojun.xie.array.simple;

public class FinalPrices {
	
	public static void main(String[] args) {
		int[] price=new int[] {8,7,4,2,8,1,7,7,10,1};
		int[] finalPrices = finalPrices(price);
		for (int i : finalPrices) {
			System.out.println(i);
		}
	}

	private static int[] finalPrices(int[] price) {
		for (int i = 0; i < price.length; i++) {
			  for (int j = i+1; j < price.length; j++) {
				if(price[i]>=price[j]) {
					price[i]=price[i]-price[j];
					break;
				}
			}
		}
		return price;
	}
}

~~~

## [1480. 一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)

~~~tex
给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 
请返回 nums 的动态和。
~~~

~~~java
package leetcode.chaojun.xie.array.simple;

public class RunningSum {
    public static void main(String[] args) {
		int[] num=new int[] {1,2,3,4};
		int[] sum = sum(num);
		for (int i : sum) {
			System.out.println(i);
		}
	}

	private static int[] sum(int[] num) {
		for (int i = 0; i < num.length; i++) {
			if(i>0) {
				num[i]=num[i]+num[i-1];
			}
		}
		return num;
	}
}

~~~

## [1486. 数组异或操作](https://leetcode-cn.com/problems/xor-operation-in-an-array/)

~~~java
给你两个整数，n 和 start 。

数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。

请返回 nums 中所有元素按位异或（XOR）后得到的结果。
~~~

~~~java
package leetcode.chaojun.xie.array.simple;

public class XorOperation {
	public static void main(String[] args) {
		int start=4;
		int n=3;
		int xorOperation = xorOperation(start, n);
		System.out.println(xorOperation);
	}

	private static int xorOperation(int n, int start) {
		/*
		 * 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。
                                    请返回 nums 中所有元素按位异或（XOR）后得到的结果
		 */
		int[]  nums=new int[n];
		int result = 0;
		for (int i = 0; i < nums.length; i++) {
			nums[i]=start + 2*i;
			result^=nums[i];
		}
		return result;
	}
}

~~~

## [1491. 去掉最低工资和最高工资后的工资平均值](https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/)

~~~java

给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。

请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。
~~~

~~~java
package leetcode.chaojun.xie.array.simple;

import java.util.Arrays;

public class Average {
	public static void main(String[] args) {
		int[] salary=new int[] {48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000};
		double average = average(salary);
		System.out.println(average);
	}

	private static double average(int[] salary) {
//		Arrays.sort(salary);
//		double sum=0.0;
//		for (int i = 1; i < salary.length-1; i++) {
//			int j= salary[i];
//			sum=sum+j;
//		}
//		return sum/(salary.length-2);
		 double sum = 0;
	        double maxValue = Integer.MIN_VALUE, minValue = Integer.MAX_VALUE;
	        for (int num : salary) {
	            sum += num;
	            maxValue = Math.max(maxValue, num);
	            minValue = Math.min(minValue, num);
	        }
	        return (sum - maxValue - minValue) / (salary.length - 2);
	}
}

~~~

