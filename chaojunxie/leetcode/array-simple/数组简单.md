## [1431. 拥有最多糖果的孩子](https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/)

~~~text
给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。

对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。

~~~

~~~java
package leetcode.chaojun.xie.array.simple;

import java.util.ArrayList;
import java.util.List;

public class KidsWithCandies {
	public static void main(String[] args) {
		int[] candies = new int[] {2,3,5,1,3};
		int extraCandies = 3;
		List<Boolean> kidsWithCandies = kidsWithCandies(candies, extraCandies);
		for (Boolean boolean1 : kidsWithCandies) {
			System.out.println(boolean1);
		}
	}

	private static List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
		List<Boolean>  list=new ArrayList<>();
//		计算数组最大值
		int maxArray = maxArray(candies);
		for (int i = 0; i < candies.length; i++) {
			int j = candies[i];
			j+=extraCandies;
			if(j>=maxArray) {
				list.add(Boolean.TRUE);
			}else {
				list.add(Boolean.FALSE);
			}
		}
		return list;
	}

	private static int maxArray(int[] candies) {
		  int max=candies[0];
		  for (int i = 1; i < candies.length; i++) {
			if(max<candies[i]) {
				max=candies[i];
			}
		}
		return max;
	}
}

~~~

## [1450. 在既定时间做作业的学生人数](https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/)

~~~text
给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。

已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。

请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。

~~~

~~~java
package leetcode.chaojun.xie.array.simple;

public class BusyStudent {
    public static void main(String[] args) {
    	int[] startTime=new int[] {1,2,3};
		int[] endTime=new int[] {3,2,7};
		int queryTime=4;
		int busyStudent = busyStudent(startTime,endTime,queryTime);
		System.out.println(busyStudent);
	}

	private static int busyStudent(int[] startTime, int[] endTime, int queryTime) {
		int count=0;
		for (int i = 0; i < endTime.length; i++) {
			int j = endTime[i];
			int m = startTime[i];
			if(queryTime<=j&&queryTime>=m) {
				count++;
			}
		}
		return count;
	}
}

~~~

## [1460. 通过翻转子数组使两个数组相等](https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/)

~~~text
给你两个长度相同的整数数组 target 和 arr 。

每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。

如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。

~~~

~~~java
package leetcode.chaojun.xie.array.simple;

import java.util.HashMap;
import java.util.Map;

public class CanBeEqual {
     public static void main(String[] args) {
		int[] arr=new int[] {1,4,2,3};
		int[] target=new int[] {1,4,3,2};  //{1,4,2,3}  {1,2,4,3} {1,2,3,4}
		boolean canBeEqual = canBeEqual(target,arr);
		System.out.println(canBeEqual);
	}

	/*
	 * private static boolean canBeEqual(int[] target, int[] arr) { // 判断不能进行翻转的情况
	 * 其他都是能翻转的 if (target.length != arr.length) { return false; }
	 * Arrays.sort(target); Arrays.sort(arr);
	 * 
	 * for (int i = 0; i < arr.length; i++) { if (target[i]!=arr[i]){ return false;
	 * } } return true; }
	 */
    	    public static boolean canBeEqual(int[] target, int[] arr) {

    	        HashMap<Integer, Integer> map1 = new HashMap<>();
    	        HashMap<Integer, Integer> map2 = new HashMap<>();

    	        for (int i : arr) {
    	            if (map1.containsKey(i)) {
    	                map1.put(i, map1.get(i) + 1);
    	            } else {
    	                map1.put(i, 1);
    	            }
    	        }

    	        for (int i : target) {
    	            if (map2.containsKey(i)){
    	                map2.put(i, map2.get(i) + 1);
    	            } else {
    	                map2.put(i, 1);
    	            }
    	        }

    	        for (Map.Entry<Integer, Integer> entry : map1.entrySet()) {
    	            if (map2.containsKey(entry.getKey())) {
    	                if (map2.get(entry.getKey()) != entry.getValue()) {
    	                    return false;
    	                }
    	            } else {
    	                return false;
    	            }
    	        }
    	        return true;
    	    }
    	}

~~~

## [1464. 数组中两元素的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/)

~~~tex
给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。

请你计算并返回该式的最大值。

~~~

~~~java
package leetcode.chaojun.xie.array.simple;

public class MaxProduct {
	public static void main(String[] args) {
		int[] nums = new int[] { 3, 4, 5, 2 };
		int maxProduct = maxProduct(nums);
		System.out.println(maxProduct);
		
	}

	private static int maxProduct(int[] nums) {
//            获取最大的两个数   采用冒泡的方式获取
		   for (int i = 0; i < 2; i++) {
			   
			for (int j=0; j < nums.length-1; j++) {
				if(nums[j]>nums[j+1]) {
					int temp=nums[j];
					nums[j]=nums[j+1];
					nums[j+1]=temp;
				}
			}
		}
		return (nums[nums.length-1]-1)*(nums[nums.length-2]-1);
	}
}

~~~

## [1470. 重新排列数组](https://leetcode-cn.com/problems/shuffle-the-array/)

~~~text
给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。

请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。
~~~

~~~java
package leetcode.chaojun.xie.array.simple;

import java.util.ArrayList;
import java.util.List;

public class Shuffle {
	public static void main(String[] args) {
		int[] nums = new int[] { 2, 5, 1, 3, 4, 7 };
		int n = 3;
		int[] shuffle = shuffle(nums, n);
		for (Integer object : shuffle) {
			System.out.println(object);
		}
	}

	private static int[] shuffle(int[] nums, int n) {
//		List<Integer>  list=new ArrayList<>();
//		int[] num=new int[2*n];
//		int count=0;
//		     for (int i = 0; i < n; i++) {
//		    	 for (int j = i; j < nums.length;) {
//		    		 num[count]=nums[j];
//		    		 count++;
//		    		 j+=n;
//					}
//			}
//			return num;
		 //1、新建一个数组用来存放排好的数
		 int[] arry = new int[nums.length];
		 
		 //2、用for来排好
		 int j =0; 
		 //循环 nums/2 次 
		 for(int i = 0 ; i < nums.length/2 ; i++){
			 arry[j++] = nums[i];  //第一个位置放 第 i个元素，每次j++自增1
			 
			 arry[j++] = nums[n +i]; //从第n+i 就是从一半开始到数组的最后
		 }
		 //3、存到新数组里
		return arry;
             
	}
}

~~~

